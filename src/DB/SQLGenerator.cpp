#include "Stdafx.h"
#include "DB/DBReader.h"
#include "DB/SQLGenerator.h"


void DB::SQLGenerator::AppendColDef(DB::SQLType sqlType, NotNullPtr<DB::SQLBuilder> sql, NotNullPtr<DB::ColDef> col, UOSInt pkCount)
{
	sql->AppendCol(col->GetColName()->v);
	sql->AppendCmdC(CSTR(" "));
	AppendColType(sqlType, sql, col->GetColType(), col->GetColSize(), col->GetColDP(), col->IsAutoInc(), col->GetNativeType());
	if (col->IsNotNull())
	{
		sql->AppendCmdC(CSTR(" NOT NULL"));
	}
	else
	{
		if (sqlType == DB::SQLType::PostgreSQL)
		{
			sql->AppendCmdC(CSTR(" NULL"));
		}
	}
	if (sqlType == DB::SQLType::MSSQL)
	{
		if (col->IsAutoInc())
		{
			sql->AppendCmdC(CSTR(" IDENTITY("));
			sql->AppendInt64(col->GetAutoIncStartIndex());
			sql->AppendCmdC(CSTR(","));
			sql->AppendInt64(col->GetAutoIncStep());
			sql->AppendCmdC(CSTR(")"));
		}
	}
	else if (sqlType == DB::SQLType::MySQL)
	{
		if (col->IsAutoInc())
		{
			sql->AppendCmdC(CSTR(" AUTO_INCREMENT"));
		}
	}
	else if (sqlType == DB::SQLType::SQLite)
	{
		if (col->IsPK() && (col->IsAutoInc() || pkCount < 2))
		{
			sql->AppendCmdC(CSTR(" PRIMARY KEY"));
		}
		if (col->IsAutoInc() && (col->GetColType() == DB::DBUtil::CT_Int32 || col->GetColType() == DB::DBUtil::CT_UInt32))
		{
			sql->AppendCmdC(CSTR(" AUTOINCREMENT"));
		}
	}
	else if (sqlType == DB::SQLType::Access)
	{
		if (col->IsPK())
		{
			sql->AppendCmdC(CSTR(" PRIMARY KEY"));
		}
	}
	else if (sqlType == DB::SQLType::PostgreSQL)
	{
		NotNullPtr<Text::String> nativeType;
		if (col->IsAutoInc())
		{
			if (col->GetNativeType().SetTo(nativeType) && (nativeType->Equals(UTF8STRC("serial")) || nativeType->Equals(UTF8STRC("smallserial")) || nativeType->Equals(UTF8STRC("bigserial"))))
			{

			}
			else
			{
 				if (col->GetAutoIncType() == DB::ColDef::AutoIncType::Always)
				{
					sql->AppendCmdC(CSTR(" GENERATED ALWAYS AS IDENTITY"));
				}
				else
				{
					sql->AppendCmdC(CSTR(" GENERATED BY DEFAULT AS IDENTITY"));
				}
				if (col->GetAutoIncStartIndex() > 1 || col->GetAutoIncStep() > 1)
				{
					sql->AppendCmdC(CSTR("(START WITH "));
					sql->AppendInt64(col->GetAutoIncStartIndex());
					sql->AppendCmdC(CSTR(" INCREMENT BY "));
					sql->AppendInt64(col->GetAutoIncStep());
					sql->AppendCmdC(CSTR(")"));
				}
			}
		}
	}

	if (!col->GetDefVal().IsNull())
	{
		if (sql->GetSQLType() == SQLType::MySQL && col->GetColType() == DB::DBUtil::CT_VarUTF32Char && col->GetColSize() >= 16384)
		{

		}
		else
		{
			sql->AppendCmdC(CSTR(" DEFAULT "));
			col->GetDefVal(sql);
		}
	}
}

void DB::SQLGenerator::AppendColType(DB::SQLType sqlType, NotNullPtr<DB::SQLBuilder> sql, DB::DBUtil::ColType colType, UOSInt colSize, UOSInt colDP, Bool autoInc, Optional<Text::String> nativeType)
{
	NotNullPtr<Text::String> s;
	switch (sqlType)
	{
	case DB::SQLType::MySQL:
		switch (colType)
		{
		case DB::DBUtil::CT_UTF8Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF16Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF32Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_VarUTF8Char:
			if (colSize >= 0x1000000)
			{
				sql->AppendCmdC(CSTR("LONGTEXT"));
			}
			else if (colSize >= 0x10000)
			{
				sql->AppendCmdC(CSTR("MEDIUMTEXT"));
			}
			else if (colSize >= 16384)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF16Char:
			if (colSize >= 0x1000000)
			{
				sql->AppendCmdC(CSTR("LONGTEXT"));
			}
			else if (colSize >= 0x10000)
			{
				sql->AppendCmdC(CSTR("MEDIUMTEXT"));
			}
			else if (colSize >= 16384)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF32Char:
			if (colSize >= 0x1000000)
			{
				sql->AppendCmdC(CSTR("LONGTEXT"));
			}
			else if (colSize >= 0x10000)
			{
				sql->AppendCmdC(CSTR("MEDIUMTEXT"));
			}
			else if (colSize >= 16384)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_DateTime:
		case DB::DBUtil::CT_DateTimeTZ:
			sql->AppendCmdC(CSTR("DATETIME("));
			if (colSize > 6)
			{
				sql->AppendUInt32(6);
			}
			else
			{
				sql->AppendUInt32((UInt32)colSize);
			}
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Date:
			sql->AppendCmdC(CSTR("DATE"));
			break;
		case DB::DBUtil::CT_Double:
			sql->AppendCmdC(CSTR("DOUBLE"));
			break;
		case DB::DBUtil::CT_Float:
			sql->AppendCmdC(CSTR("FLOAT"));
			break;
		case DB::DBUtil::CT_Decimal:
			sql->AppendCmdC(CSTR("DECIMAL("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(","));
			sql->AppendUInt32((UInt32)colDP);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Bool:
			sql->AppendCmdC(CSTR("TINYINT(1)"));
			break;
		case DB::DBUtil::CT_Byte:
			sql->AppendCmdC(CSTR("TINYINT(3)"));
			break;
		case DB::DBUtil::CT_Int16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_Int32:
			sql->AppendCmdC(CSTR("INTEGER"));
			break;
		case DB::DBUtil::CT_Int64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_UInt16:
			sql->AppendCmdC(CSTR("SMALLINT UNSIGNED"));
			break;
		case DB::DBUtil::CT_UInt32:
			sql->AppendCmdC(CSTR("INTEGER UNSIGNED"));
			break;
		case DB::DBUtil::CT_UInt64:
			sql->AppendCmdC(CSTR("BIGINT UNSIGNED"));
			break;
		case DB::DBUtil::CT_Binary:
			if (colSize >= 16384)
			{
				sql->AppendCmdC(CSTR("BLOB"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARBINARY("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Vector:
			sql->AppendCmdC(CSTR("GEOMETRY"));
			break;
		case DB::DBUtil::CT_UUID:
			sql->AppendCmdC(CSTR("VARCHAR(36)"));
			break;
		case DB::DBUtil::CT_Unknown:
		default:
			////////////////////////////////////////////////////////
			break;
		}
		break;
	case DB::SQLType::MSSQL:
		switch (colType)
		{
		case DB::DBUtil::CT_UTF8Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF16Char:
			sql->AppendCmdC(CSTR("NCHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF32Char:
			sql->AppendCmdC(CSTR("NCHAR("));
			sql->AppendUInt32((UInt32)(colSize * 2));
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_VarUTF8Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("VARCHAR(MAX)"));
			}
			else if (colSize > 8000)
			{
				sql->AppendCmdC(CSTR("VARCHAR(MAX)"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF16Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("NVARCHAR(MAX)"));
			}
			else if (colSize > 4000)
			{
				sql->AppendCmdC(CSTR("NVARCHAR(MAX)"));
			}
			else
			{
				sql->AppendCmdC(CSTR("NVARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF32Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("NVARCHAR(MAX)"));
			}
			else if (colSize > 2000)
			{
				sql->AppendCmdC(CSTR("NVARCHAR(MAX)"));
			}
			else
			{
				sql->AppendCmdC(CSTR("NVARCHAR("));
				sql->AppendUInt32((UInt32)(colSize * 2));
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Date:
			sql->AppendCmdC(CSTR("DATE"));
			break;
		case DB::DBUtil::CT_DateTime:
			sql->AppendCmdC(CSTR("DATETIME2("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_DateTimeTZ:
			sql->AppendCmdC(CSTR("DATETIMEOFFSET("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Double:
			sql->AppendCmdC(CSTR("BINARY_DOUBLE"));
			break;
		case DB::DBUtil::CT_Float:
			sql->AppendCmdC(CSTR("BINARY_FLOAT"));
			break;
		case DB::DBUtil::CT_Decimal:
			sql->AppendCmdC(CSTR("DECIMAL("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(","));
			sql->AppendUInt32((UInt32)colDP);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Bool:
			sql->AppendCmdC(CSTR("BOOL"));
			break;
		case DB::DBUtil::CT_Byte:
			sql->AppendCmdC(CSTR("BYTE"));
			break;
		case DB::DBUtil::CT_Int16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_Int32:
			sql->AppendCmdC(CSTR("INT"));
			break;
		case DB::DBUtil::CT_Int64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_UInt16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_UInt32:
			sql->AppendCmdC(CSTR("INT"));
			break;
		case DB::DBUtil::CT_UInt64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_Binary:
			if (colSize > 8000)
			{
				sql->AppendCmdC(CSTR("VARBINARY(MAX)"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARBINARY("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Vector:
			sql->AppendCmdC(CSTR("GEOMETRY"));
			break;
		case DB::DBUtil::CT_UUID:
			sql->AppendCmdC(CSTR("UNIQUEIDENTIFIER"));
			break;
		case DB::DBUtil::CT_Unknown:
		default:
			////////////////////////////////////////
			break;
		}
		break;
	case DB::SQLType::MDBTools:
	case DB::SQLType::Access:
		switch (colType)
		{
		case DB::DBUtil::CT_UTF8Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF16Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)(colSize * 3));
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF32Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)(colSize * 4));
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_VarUTF8Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else if (colSize > 255)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF16Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else if (colSize > 255)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)(colSize * 3));
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF32Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else if (colSize > 255)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)(colSize * 4));
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Date:
			sql->AppendCmdC(CSTR("DATE"));
			break;
		case DB::DBUtil::CT_DateTime:
			sql->AppendCmdC(CSTR("DATETIME"));
			break;
		case DB::DBUtil::CT_DateTimeTZ:
			sql->AppendCmdC(CSTR("DATETIME"));
			break;
		case DB::DBUtil::CT_Double:
			sql->AppendCmdC(CSTR("DOUBLE"));
			break;
		case DB::DBUtil::CT_Float:
			sql->AppendCmdC(CSTR("SINGLE"));
			break;
		case DB::DBUtil::CT_Decimal:
			sql->AppendCmdC(CSTR("DECIMAL("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(","));
			sql->AppendUInt32((UInt32)colDP);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Bool:
			sql->AppendCmdC(CSTR("BOOL"));
			break;
		case DB::DBUtil::CT_Byte:
			sql->AppendCmdC(CSTR("BYTE"));
			break;
		case DB::DBUtil::CT_Int16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_Int32:
			sql->AppendCmdC(CSTR("INT"));
			break;
		case DB::DBUtil::CT_Int64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_UInt16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_UInt32:
			sql->AppendCmdC(CSTR("INT"));
			break;
		case DB::DBUtil::CT_UInt64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_Binary:
		case DB::DBUtil::CT_Vector:
		case DB::DBUtil::CT_UUID:
		case DB::DBUtil::CT_Unknown:
		default:
			////////////////////////////////////////
			break;
		}
		break;
	case DB::SQLType::SQLite:
		switch (colType)
	 	{
		case DB::DBUtil::CT_UTF8Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF16Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)(colSize));
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF32Char:
			sql->AppendCmdC(CSTR("CHAR("));
			sql->AppendUInt32((UInt32)(colSize));
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_VarUTF8Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF16Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)(colSize));
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF32Char:
			if (colSize == (UOSInt)-1)
			{
				sql->AppendCmdC(CSTR("TEXT"));
			}
			else
			{
				sql->AppendCmdC(CSTR("VARCHAR("));
				sql->AppendUInt32((UInt32)(colSize));
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Date:
			sql->AppendCmdC(CSTR("DATE"));
			break;
		case DB::DBUtil::CT_DateTime:
			sql->AppendCmdC(CSTR("DATETIME"));
			break;
		case DB::DBUtil::CT_DateTimeTZ:
			sql->AppendCmdC(CSTR("DATETIME"));
			break;
		case DB::DBUtil::CT_Double:
			sql->AppendCmdC(CSTR("DOUBLE"));
			break;
		case DB::DBUtil::CT_Float:
			sql->AppendCmdC(CSTR("FLOAT"));
			break;
		case DB::DBUtil::CT_Decimal:
			sql->AppendCmdC(CSTR("DECIMAL("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(","));
			sql->AppendUInt32((UInt32)colDP);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Bool:
			sql->AppendCmdC(CSTR("BOOLEAN"));
			break;
		case DB::DBUtil::CT_Byte:
			sql->AppendCmdC(CSTR("TINYINT"));
			break;
		case DB::DBUtil::CT_Int16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_Int32:
			sql->AppendCmdC(CSTR("INTEGER"));
			break;
		case DB::DBUtil::CT_Int64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_UInt16:
			sql->AppendCmdC(CSTR("SMALLINT"));
			break;
		case DB::DBUtil::CT_UInt32:
			sql->AppendCmdC(CSTR("INTEGER"));
			break;
		case DB::DBUtil::CT_UInt64:
			sql->AppendCmdC(CSTR("BIGINT"));
			break;
		case DB::DBUtil::CT_Binary:
			sql->AppendCmdC(CSTR("BLOB"));
			break;
		case DB::DBUtil::CT_Vector:
			switch ((DB::ColDef::GeometryType)colSize)
			{
			default:
			case DB::ColDef::GeometryType::Unknown:
			case DB::ColDef::GeometryType::Any:
			case DB::ColDef::GeometryType::AnyZ:
			case DB::ColDef::GeometryType::AnyZM:
			case DB::ColDef::GeometryType::AnyM:
				sql->AppendCmdC(CSTR("GEOMETRY"));
				break;
			case DB::ColDef::GeometryType::Point:
			case DB::ColDef::GeometryType::PointZ:
			case DB::ColDef::GeometryType::PointZM:
			case DB::ColDef::GeometryType::PointM:
				sql->AppendCmdC(CSTR("POINT"));
				break;
			case DB::ColDef::GeometryType::Multipoint:
			case DB::ColDef::GeometryType::MultipointZ:
			case DB::ColDef::GeometryType::MultipointZM:
			case DB::ColDef::GeometryType::MultipointM:
				sql->AppendCmdC(CSTR("MULTIPOINT"));
				break;
			case DB::ColDef::GeometryType::Polyline:
			case DB::ColDef::GeometryType::PolylineZ:
			case DB::ColDef::GeometryType::PolylineZM:
			case DB::ColDef::GeometryType::PolylineM:
				sql->AppendCmdC(CSTR("POLYLINE"));
				break;
			case DB::ColDef::GeometryType::Polygon:
			case DB::ColDef::GeometryType::PolygonZ:
			case DB::ColDef::GeometryType::PolygonZM:
			case DB::ColDef::GeometryType::PolygonM:
				sql->AppendCmdC(CSTR("POLYGON"));
				break;
			case DB::ColDef::GeometryType::Rectangle:
			case DB::ColDef::GeometryType::RectangleZ:
			case DB::ColDef::GeometryType::RectangleZM:
			case DB::ColDef::GeometryType::RectangleM:
				sql->AppendCmdC(CSTR("RECTANGLE"));
				break;
			case DB::ColDef::GeometryType::Path:
			case DB::ColDef::GeometryType::PathZ:
			case DB::ColDef::GeometryType::PathZM:
			case DB::ColDef::GeometryType::PathM:
				sql->AppendCmdC(CSTR("PATH"));
				break;
			case DB::ColDef::GeometryType::MultiPolygon:
			case DB::ColDef::GeometryType::MultiPolygonZ:
			case DB::ColDef::GeometryType::MultiPolygonZM:
			case DB::ColDef::GeometryType::MultiPolygonM:
				sql->AppendCmdC(CSTR("MULTIPOLYGON"));
				break;
			}
		case DB::DBUtil::CT_UUID:
		case DB::DBUtil::CT_Unknown:
		default:
			////////////////////////////////////////
			break;
		}
		break;
	case DB::SQLType::PostgreSQL:
		switch (colType)
	 	{
		case DB::DBUtil::CT_UTF8Char:
			sql->AppendCmdC(CSTR("char("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF16Char:
			sql->AppendCmdC(CSTR("char("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_UTF32Char:
			if (!nativeType.SetTo(s))
				sql->AppendCmdC(CSTR("char("));
			else if (s->Equals(UTF8STRC("bpchar")))
				sql->AppendCmdC(CSTR("bpchar("));
			else
				sql->AppendCmdC(CSTR("char("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_VarUTF8Char:
			if (colSize > 10485760)
			{
				sql->AppendCmdC(CSTR("text"));
			}
			else
			{
				sql->AppendCmdC(CSTR("varchar("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF16Char:
			if (colSize > 10485760)
			{
				sql->AppendCmdC(CSTR("text"));
			}
			else
			{
				sql->AppendCmdC(CSTR("varchar("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_VarUTF32Char:
			if (nativeType.SetTo(s) && colSize == 268435456 && s->Equals(UTF8STRC("varchar")))
				sql->AppendCmdC(CSTR("varchar"));
			else if (nativeType.SetTo(s) && colSize == 268435456 && s->Equals(UTF8STRC("citext")))
				sql->AppendCmdC(CSTR("citext"));
			else if (colSize > 10485760)
				sql->AppendCmdC(CSTR("text"));
			else
			{
				sql->AppendCmdC(CSTR("varchar("));
				sql->AppendUInt32((UInt32)colSize);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_Date:
			sql->AppendCmdC(CSTR("date"));
			break;
		case DB::DBUtil::CT_DateTime:
			sql->AppendCmdC(CSTR("timestamp("));
			if (colSize > 6)
			{
				sql->AppendUInt32(6);
			}
			else
			{
				sql->AppendUInt32((UInt32)colSize);
			}
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_DateTimeTZ:
			sql->AppendCmdC(CSTR("timestamptz("));
			if (colSize > 6)
			{
				sql->AppendUInt32(6);
			}
			else
			{
				sql->AppendUInt32((UInt32)colSize);
			}
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Double:
			sql->AppendCmdC(CSTR("float8"));
			break;
		case DB::DBUtil::CT_Float:
			sql->AppendCmdC(CSTR("real"));
			break;
		case DB::DBUtil::CT_Decimal:
			sql->AppendCmdC(CSTR("numeric("));
			sql->AppendUInt32((UInt32)colSize);
			sql->AppendCmdC(CSTR(","));
			sql->AppendUInt32((UInt32)colDP);
			sql->AppendCmdC(CSTR(")"));
			break;
		case DB::DBUtil::CT_Bool:
			sql->AppendCmdC(CSTR("bool"));
			break;
		case DB::DBUtil::CT_Byte:
			sql->AppendCmdC(CSTR("smallint"));
			break;
		case DB::DBUtil::CT_Int16:
			if (!nativeType.SetTo(s))
				sql->AppendCmdC(CSTR("smallint"));
			else if (s->Equals(UTF8STRC("int2")))
				sql->AppendCmdC(CSTR("int2"));
			else if (autoInc && s->Equals(CSTR("smallserial")))
				sql->AppendCmdC(CSTR("smallserial"));
			else
				sql->AppendCmdC(CSTR("smallint"));
			break;
		case DB::DBUtil::CT_Int32:
			if (!nativeType.SetTo(s))
				sql->AppendCmdC(CSTR("integer"));
			else if (s->Equals(UTF8STRC("int4")))
				sql->AppendCmdC(CSTR("int4"));
			else if (autoInc && s->Equals(CSTR("serial")))
				sql->AppendCmdC(CSTR("serial"));
			else
				sql->AppendCmdC(CSTR("integer"));
			break;
		case DB::DBUtil::CT_Int64:
			if (!nativeType.SetTo(s))
				sql->AppendCmdC(CSTR("bigint"));
			else if (s->Equals(UTF8STRC("int8")))
				sql->AppendCmdC(CSTR("int8"));
			else if (autoInc && s->Equals(CSTR("bigserial")))
				sql->AppendCmdC(CSTR("bigserial"));
			else
				sql->AppendCmdC(CSTR("bigint"));
			break;
		case DB::DBUtil::CT_UInt16:
			if (autoInc)
			{
				sql->AppendCmdC(CSTR("smallserial"));
			}
			else
			{
				sql->AppendCmdC(CSTR("smallint"));
			}
			break;
		case DB::DBUtil::CT_UInt32:
			if (autoInc)
			{
				sql->AppendCmdC(CSTR("serial"));
			}
			else
			{
				sql->AppendCmdC(CSTR("integer"));
			}
			break;
		case DB::DBUtil::CT_UInt64:
			if (autoInc)
			{
				sql->AppendCmdC(CSTR("bigserial"));
			}
			else
			{
				sql->AppendCmdC(CSTR("bigint"));
			}
			break;
		case DB::DBUtil::CT_Binary:
			sql->AppendCmdC(CSTR("bytea"));
			break;
		case DB::DBUtil::CT_Vector:
			if (colSize == 0 && colDP == 0)
				sql->AppendCmdC(CSTR("geometry"));
			else
			{
				sql->AppendCmdC(CSTR("geometry("));
				sql->AppendCmdC(DB::ColDef::GeometryTypeGetName((DB::ColDef::GeometryType)colSize));
				sql->AppendCmdC(CSTR(","));
				sql->AppendUInt32((UInt32)colDP);
				sql->AppendCmdC(CSTR(")"));
			}
			break;
		case DB::DBUtil::CT_UUID:
			sql->AppendCmdC(CSTR("uuid"));
			break;
		case DB::DBUtil::CT_Unknown:
		default:
			////////////////////////////////////////
			break;
		}
		break;
	case DB::SQLType::Unknown:
	case DB::SQLType::Oracle:
	case DB::SQLType::WBEM:
	default:
		break;
	}
}

Bool DB::SQLGenerator::GenCreateTableCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName, NotNullPtr<DB::TableDef> tabDef, Bool multiline)
{
	DB::SQLType sqlType = sql->GetSQLType();
	Data::ArrayIterator<NotNullPtr<DB::ColDef>> it;
	Bool found;
	UOSInt pkCnt = tabDef->CountPK();
	Bool hasAutoInc = false;
	Int64 autoIncStart = 1;
//	Int64 autoIncStep = 1;
	NotNullPtr<DB::ColDef> col;
	sql->AppendCmdC(CSTR("create table "));
	if (schemaName.leng > 0 && sql->SupportSchema())
	{
		sql->AppendCol(schemaName.v);
		sql->AppendCmdC(CSTR("."));
	}
	sql->AppendCol(tableName.v);
	sql->AppendCmdC(CSTR(" ("));
	if (sqlType == DB::SQLType::Access || sqlType == DB::SQLType::MDBTools)
	{
		found = false;
		it = tabDef->ColIterator();
		while (it.HasNext())
		{
			if (found)
				sql->AppendCmdC(CSTR(", "));
			if (multiline) sql->AppendCmdC(CSTR("\r\n\t"));
			col = it.Next();
			AppendColDef(sqlType, sql, col, pkCnt);
			found = true;
		}
	}
	else if (sqlType == DB::SQLType::SQLite)
	{
		found = false;
		it = tabDef->ColIterator();
		while (it.HasNext())
		{
			if (found)
				sql->AppendCmdC(CSTR(", "));
			if (multiline) sql->AppendCmdC(CSTR("\r\n\t"));
			col = it.Next();
			AppendColDef(sqlType, sql, col, pkCnt);
			if (col->IsAutoInc())
			{
				hasAutoInc = true;
			}
			found = true;
		}
		if (!hasAutoInc && pkCnt > 1)
		{
			sql->AppendCmdC(CSTR(", "));
			sql->AppendCmdC(CSTR("PRIMARY KEY ("));
			it = tabDef->ColIterator();
			found = false;
			while (it.HasNext())
			{
				col = it.Next();
				if (col->IsPK())
				{
					if (found)
						sql->AppendCmdC(CSTR(", "));
					sql->AppendCol(col->GetColName()->v);
					found = true;
				}
			}
			sql->AppendCmdC(CSTR(")"));
		}
	}
	else
	{
		it = tabDef->ColIterator();
		found = false;
		while (it.HasNext())
		{
			col = it.Next();
			if (found) sql->AppendCmdC(CSTR(", "));
			if (multiline) sql->AppendCmdC(CSTR("\r\n\t"));
			AppendColDef(sqlType, sql, col, pkCnt);
			if (col->IsAutoInc())
			{
				hasAutoInc = true;
				autoIncStart = col->GetAutoIncStartIndex();
//				autoIncStep = col->GetAutoIncStep();
			}
			found = true;
		}
		it = tabDef->ColIterator();
		found = false;
		while (it.HasNext())
		{
			col = it.Next();
			if (col->IsPK())
			{
				if (found)
				{
					sql->AppendCmdC(CSTR(", "));
				}
				else
				{
					sql->AppendCmdC(CSTR(", "));
					if (multiline) sql->AppendCmdC(CSTR("\r\n\t"));
					sql->AppendCmdC(CSTR("PRIMARY KEY ("));
				}
				sql->AppendCol(col->GetColName()->v);
				found = true;
			}
		}
		if (found)
		{
			sql->AppendCmdC(CSTR(")"));
		}
	}
	if (multiline) sql->AppendCmdC(CSTR("\r\n"));
	sql->AppendCmdC(CSTR(")"));
	NotNullPtr<Text::String> s;
	if (sqlType == DB::SQLType::MySQL)
	{
		if (tabDef->GetEngine().SetTo(s))
		{
			sql->AppendCmdC(CSTR(" ENGINE="));
			sql->AppendCmdC(s->ToCString());
		}
		if (tabDef->GetCharset().SetTo(s))
		{
			sql->AppendCmdC(CSTR(" DEFAULT CHARSET="));
			sql->AppendCmdC(s->ToCString());
		}
		if (hasAutoInc)
		{
			sql->AppendCmdC(CSTR(" AUTO_INCREMENT="));
			sql->AppendInt64(autoIncStart);
		}
	}
	return true;
}

Bool DB::SQLGenerator::GenInsertCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName, NotNullPtr<DB::DBReader> r)
{
	return GenInsertCmd(sql, schemaName, tableName, 0, r);
}

Bool DB::SQLGenerator::GenInsertCmd(NotNullPtr<DB::SQLBuilder> sql, NotNullPtr<DB::TableDef> tabDef, NotNullPtr<DB::DBReader> r)
{
	return GenInsertCmd(sql, OPTSTR_CSTR(tabDef->GetSchemaName()), tabDef->GetTableName()->ToCString(), tabDef, r);
}

Bool DB::SQLGenerator::GenInsertCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName, Optional<DB::TableDef> tabDef, NotNullPtr<DB::DBReader> r)
{
	UTF8Char tmpBuff[256];
	NotNullPtr<DB::TableDef> nntabDef;
	DB::DBUtil::ColType colType;
	UOSInt i;
	UOSInt j;

	Text::StringBuilderUTF8 sb;
	Data::DateTime dt;

	sql->AppendCmdC(CSTR("insert into "));
	if (schemaName.leng > 0 && sql->SupportSchema())
	{
		sql->AppendCol(schemaName.v);
		sql->AppendCmdC(CSTR("."));
	}
	sql->AppendCol(tableName.v);
	sql->AppendCmdC(CSTR(" ("));
	j = r->ColCount();
	i = 1;
	r->GetName(0, tmpBuff);
	sql->AppendCol(tmpBuff);
	while (i < j)
	{
		r->GetName(i, tmpBuff);
		sql->AppendCmdC(CSTR(", "));
		sql->AppendCol(tmpBuff);
		i++;
	}
	if (tabDef.SetTo(nntabDef) && sql->GetSQLType() == DB::SQLType::PostgreSQL)
	{
		Bool hasAutoIncAlways = false;
		NotNullPtr<DB::ColDef> col;
		Data::ArrayIterator<NotNullPtr<DB::ColDef>> it = nntabDef->ColIterator();
		while (it.HasNext())
		{
			col = it.Next();
			if (col->GetAutoIncType() == DB::ColDef::AutoIncType::Always)
			{
				hasAutoIncAlways = true;
				break;
			}
		}
		if (hasAutoIncAlways)
			sql->AppendCmdC(CSTR(") overriding system value values ("));
		else
			sql->AppendCmdC(CSTR(") values ("));
	}
	else
	{
		sql->AppendCmdC(CSTR(") values ("));
	}
	i = 0;
	while (i < j)
	{
		if (i > 0)
		{
			sql->AppendCmdC(CSTR(", "));
		}
		if (r->IsNull(i))
		{
			sql->AppendCmdC(CSTR("NULL"));
		}
		else
		{
			Optional<Math::Geometry::Vector2D> vec;
			UInt8 *binBuff;
			UOSInt colSize;
			colType = r->GetColType(i, colSize);
			switch (colType)
			{
			case DB::DBUtil::CT_Bool:
				sql->AppendBool(r->GetBool(i));
				break;
			case DB::DBUtil::CT_DateTimeTZ:
			case DB::DBUtil::CT_DateTime:
				sql->AppendTS(r->GetTimestamp(i));
				break;
			case DB::DBUtil::CT_Date:
				sql->AppendDate(r->GetDate(i));
				break;
			case DB::DBUtil::CT_Int64:
				sql->AppendInt64(r->GetInt64(i));
				break;
			case DB::DBUtil::CT_Int32:
			case DB::DBUtil::CT_Int16:
				sql->AppendInt32(r->GetInt32(i));
				break;
			case DB::DBUtil::CT_UInt64:
				sql->AppendUInt64((UInt64)r->GetInt64(i));
				break;
			case DB::DBUtil::CT_UInt32:
			case DB::DBUtil::CT_UInt16:
			case DB::DBUtil::CT_Byte:
				sql->AppendUInt32((UInt32)r->GetInt32(i));
				break;
			case DB::DBUtil::CT_Double:
			case DB::DBUtil::CT_Float:
				sql->AppendDbl(r->GetDbl(i));
				break;
			case DB::DBUtil::CT_Decimal:
				sql->AppendDbl(r->GetDbl(i));
				break;
			case DB::DBUtil::CT_Vector:
				vec = r->GetVector(i);
				sql->AppendVector(vec);
				vec.Delete();
				break;
			case DB::DBUtil::CT_Binary:
				if (r->IsNull(i))
				{
					sql->AppendStrUTF8(0);
				}
				else
				{
					UOSInt sz = r->GetBinarySize(i);
					binBuff = MemAlloc(UInt8, sz);
					r->GetBinary(i, binBuff);
					sql->AppendBinary(binBuff, sz);
					MemFree(binBuff);
				}
				break;
			case DB::DBUtil::CT_UUID:
/*			{
				Data::UUID uuid;
				r->GetUUID(i, &uuid);
				sql->AppendUUID(&uuid);
			}*/
			case DB::DBUtil::CT_UTF8Char:
			case DB::DBUtil::CT_UTF16Char:
			case DB::DBUtil::CT_UTF32Char:
			case DB::DBUtil::CT_VarUTF8Char:
			case DB::DBUtil::CT_VarUTF16Char:
			case DB::DBUtil::CT_VarUTF32Char:
			case DB::DBUtil::CT_Unknown:
			default:
				sb.ClearStr();
				r->GetStr(i, sb);
				sql->AppendStrC(sb.ToCString());
				break;
			}
		}
		i++;
	}
	sql->AppendCmdC(CSTR(")"));
	return true;
}

Bool DB::SQLGenerator::GenCreateDatabaseCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString databaseName, const Collation *collation)
{
	UTF8Char sbuff[128];
	UTF8Char *sptr;
	sql->AppendCmdC(CSTR("CREATE DATABASE "));
	sql->AppendCol(databaseName.v);
	if (collation != 0)
	{
		if (sql->GetSQLType() == SQLType::MySQL)
		{
			sql->AppendCmdC(CSTR(" CHARACTER SET "));
			sptr = DB::DBUtil::SDBCharset(sbuff, collation->charset, SQLType::MySQL);
			sql->AppendCmdC(CSTRP(sbuff, sptr));
			sql->AppendCmdC(CSTR(" COLLATE "));
			sptr = DB::DBUtil::SDBCollation(sbuff, collation, SQLType::MySQL);
			sql->AppendCmdC(CSTRP(sbuff, sptr));
		}
	}
	return true;
}

Bool DB::SQLGenerator::GenDeleteDatabaseCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString databaseName)
{
	sql->AppendCmdC(CSTR("DROP DATABASE "));
	sql->AppendCol(databaseName.v);
	return true;
}

Bool DB::SQLGenerator::GenCreateSchemaCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName)
{
	sql->AppendCmdC(CSTR("CREATE SCHEMA "));
	sql->AppendCol(schemaName.v);
	return true;
}

Bool DB::SQLGenerator::GenDeleteSchemaCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName)
{
	sql->AppendCmdC(CSTR("DROP SCHEMA "));
	sql->AppendCol(schemaName.v);
	return true;
}

Bool DB::SQLGenerator::GenDropTableCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName)
{
	sql->AppendCmdC(CSTR("drop table "));
	if (schemaName.leng > 0 && sql->SupportSchema())
	{
		sql->AppendCol(schemaName.v);
		sql->AppendCmdC(CSTR("."));
	}
	sql->AppendCol(tableName.v);
	return true;
}

Bool DB::SQLGenerator::GenDeleteTableDataCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName)
{
	sql->AppendCmdC(CSTR("delete from "));
	if (schemaName.leng > 0 && sql->SupportSchema())
	{
		sql->AppendCol(schemaName.v);
		sql->AppendCmdC(CSTR("."));
	}
	sql->AppendCol(tableName.v);
	return true;
}

Bool DB::SQLGenerator::GenTruncateTableCmd(NotNullPtr<DB::SQLBuilder> sql, Text::CString schemaName, Text::CStringNN tableName)
{
	sql->AppendCmdC(CSTR("truncate table "));
	if (schemaName.leng > 0 && sql->SupportSchema())
	{
		sql->AppendCol(schemaName.v);
		sql->AppendCmdC(CSTR("."));
	}
	sql->AppendCol(tableName.v);
	return true;
}

DB::SQLGenerator::PageStatus DB::SQLGenerator::GenSelectCmdPage(NotNullPtr<DB::SQLBuilder> sql, NotNullPtr<DB::TableDef> tabDef, Optional<DB::PageRequest> page)
{
	DB::SQLGenerator::PageStatus status;
	NotNullPtr<DB::PageRequest> nnpage;
	if (page.NotNull())
	{
		status = PageStatus::NoPage;
	}
	else
	{
		status = PageStatus::Succ;
	}
	NotNullPtr<DB::ColDef> col;
	Data::ArrayIterator<NotNullPtr<DB::ColDef>> it;
	it = tabDef->ColIterator();
	Bool found = false;
	sql->AppendCmdC(CSTR("select "));
	if (page.SetTo(nnpage) && (sql->GetSQLType() == DB::SQLType::Access))
	{
		sql->AppendCmdC(CSTR("TOP "));
		sql->AppendInt32((Int32)((nnpage->GetPageNum() + 1) * nnpage->GetPageSize()));
		status = PageStatus::NoOffset;
	}
	while (it.HasNext())
	{
		col = it.Next();
		if (found)
			sql->AppendCmdC(CSTR(", "));
		sql->AppendCol(col->GetColName()->v);
		found = true;
	}
	sql->AppendCmdC(CSTR(" from "));
	sql->AppendTableName(tabDef);
	if (page.SetTo(nnpage))
	{
		Bool hasOrder = false;
		UOSInt i = 1;
		UOSInt j = nnpage->GetSortingCount();
		if (j > 0)
		{
			hasOrder = true;
			sql->AppendCmdC(CSTR(" order by "));
			sql->AppendCol(nnpage->GetSortColumn(0));
			if (nnpage->IsSortDesc(0))
			{
				sql->AppendCmdC(CSTR(" desc"));
			}
			while (i < j)
			{
				sql->AppendCmdC(CSTR(", "));
				sql->AppendCol(nnpage->GetSortColumn(i));
				if (nnpage->IsSortDesc(i))
				{
					sql->AppendCmdC(CSTR(" desc"));
				}
				i++;
			}
		}

		if (sql->GetSQLType() == DB::SQLType::MySQL)
		{
			sql->AppendCmdC(CSTR(" LIMIT "));
			sql->AppendInt32((Int32)(nnpage->GetPageNum() * nnpage->GetPageSize()));
			sql->AppendCmdC(CSTR(", "));
			sql->AppendInt32((Int32)nnpage->GetPageSize());
			status = PageStatus::Succ;
		}
		else if (sql->GetSQLType() == DB::SQLType::MSSQL)
		{
			if (!hasOrder)
			{
				it = tabDef->ColIterator();
				while (it.HasNext())
				{
					col = it.Next();
					if (col->IsPK())
					{
						if (hasOrder)
						{
							sql->AppendCmdC(CSTR(", "));
						}
						else
						{
							hasOrder = true;
							sql->AppendCmdC(CSTR(" order by "));
						}
						sql->AppendCol(col->GetColName()->v);
					}
					i++;
				}
			}
			if (hasOrder)
			{
				status = PageStatus::Succ;
				sql->AppendCmdC(CSTR(" offset "));
				sql->AppendInt32((Int32)(nnpage->GetPageNum() * nnpage->GetPageSize()));
				sql->AppendCmdC(CSTR(" row fetch next "));
				sql->AppendInt32((Int32)nnpage->GetPageSize());
				sql->AppendCmdC(CSTR(" row only"));
			}
			else
			{
				status = PageStatus::NoPage;
			}
		}
	}
	return status;
}

UTF8Char *DB::SQLGenerator::GenInsertCmd(UTF8Char *sqlstr, DB::SQLType sqlType, Text::CString schemaName, Text::CStringNN tableName, NotNullPtr<DB::DBReader> r)
{
	UTF8Char *currPtr;
	UTF8Char tmpBuff[256];
	UOSInt i;
	UOSInt j;

	currPtr = Text::StrConcatC(sqlstr, UTF8STRC("insert into "));
	if (schemaName.leng > 0)
	{
		currPtr = DB::DBUtil::SDBColUTF8(currPtr, schemaName.v, sqlType);
		currPtr = Text::StrConcatC(currPtr, UTF8STRC("."));
	}
	currPtr = DB::DBUtil::SDBColUTF8(currPtr, tableName.v, sqlType);
	r->GetName(0, tmpBuff);
	currPtr = DB::DBUtil::SDBColUTF8(currPtr, tmpBuff, sqlType);
	j = r->ColCount();
	i = 1;
	while (i < j)
	{
		currPtr = Text::StrConcatC(currPtr, UTF8STRC(", "));
		r->GetName(i++, tmpBuff);
		currPtr = DB::DBUtil::SDBColUTF8(currPtr, tmpBuff, sqlType);
	}
	currPtr = Text::StrConcatC(currPtr, UTF8STRC(") values ("));
	if (r->IsNull(0))
	{
		currPtr = Text::StrConcatC(currPtr, UTF8STRC("NULL"));
	}
	else
	{
		r->GetStr(0, tmpBuff, sizeof(tmpBuff));
		currPtr = DB::DBUtil::SDBStrUTF8(currPtr, tmpBuff, sqlType);
	}
	i = 1;
	while (i < j)
	{
		currPtr = Text::StrConcatC(currPtr, UTF8STRC(", "));
		if (r->IsNull(i))
		{
			currPtr = Text::StrConcatC(currPtr, UTF8STRC("NULL"));
		}
		else
		{
			r->GetStr(i, tmpBuff, sizeof(tmpBuff));
			currPtr = DB::DBUtil::SDBStrUTF8(currPtr, tmpBuff, sqlType);
		}
		i++;
	}

	currPtr = Text::StrConcatC(currPtr, UTF8STRC(")"));
	return currPtr;
}
