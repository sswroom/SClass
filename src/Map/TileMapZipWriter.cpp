#include "Stdafx.h"
#include "IO/Path.h"
#include "Map/TileMapZipWriter.h"
#include "Text/JSONBuilder.h"

Map::TileMapZipWriter::TileMapZipWriter(Text::CStringNN fileName, Map::TileMap::ImageType imgType, UOSInt minLev, UOSInt maxLev, Math::RectAreaDbl bounds) : fs(fileName, IO::FileMode::Create, IO::FileShare::DenyNone, IO::FileStream::BufferType::Normal), zip(fs, IO::ZIPOS::UNIX)
{
	this->imgType = imgType;
	this->minLev = minLev;
	this->maxLev = maxLev;
	this->bounds = bounds;
	UOSInt i;
	UOSInt j;
	i = fileName.LastIndexOf(IO::Path::PATH_SEPERATOR);
	j = fileName.LastIndexOf('.', i + 1);
	if (j == INVALID_INDEX)
	{
		this->name = Text::String::New(fileName.Substring(i + 1));
	}
	else
	{
		this->name = Text::String::New(fileName.v + i + 1, j - i - 1);
	}
	this->currLev = 0;
}

Map::TileMapZipWriter::~TileMapZipWriter()
{
	UTF8Char sbuff[64];
	UTF8Char *sptr;
	Text::JSONBuilder json(Text::JSONBuilder::OT_OBJECT);
	json.ObjectAddStr(CSTR("name"), this->name);
	json.ObjectAddStr(CSTR("version"), CSTR("1.0"));
	json.ObjectAddStr(CSTR("description"), CSTR(""));
	json.ObjectAddStr(CSTR("attribution"), CSTR("Generated by AVIRead (sswroom)"));
	json.ObjectAddStr(CSTR("type"), CSTR("overlay"));
	switch (this->imgType)
	{
	case Map::TileMap::IT_WEBP:
		json.ObjectAddStr(CSTR("format"), CSTR("webp"));
		break;
	case Map::TileMap::IT_JPG:
		json.ObjectAddStr(CSTR("format"), CSTR("jpg"));
		break;
	case Map::TileMap::IT_PNG:
		json.ObjectAddStr(CSTR("format"), CSTR("png"));
		break;
	}
	sptr = Text::StrUOSInt(sbuff, this->minLev);
	json.ObjectAddStr(CSTR("minzoom"), CSTRP(sbuff, sptr));
	sptr = Text::StrUOSInt(sbuff, this->maxLev);
	json.ObjectAddStr(CSTR("maxzoom"), CSTRP(sbuff, sptr));
	json.ObjectAddStr(CSTR("scale"), CSTR("1.000000"));
	json.ObjectBeginArray(CSTR("bounds"));
	json.ArrayAddFloat64(this->bounds.tl.x);
	json.ArrayAddFloat64(this->bounds.tl.y);
	json.ArrayAddFloat64(this->bounds.br.x);
	json.ArrayAddFloat64(this->bounds.br.y);
	json.ArrayEnd();
	json.ObjectAddStr(CSTR("profile"), CSTR("mercator"));
	Text::CStringNN metadata = json.Build();
	Data::Timestamp t = Data::Timestamp::UtcNow();
	this->zip.AddFile(CSTR("metadata.json"), metadata.v, metadata.leng, t, t, t, Data::Compress::Inflate::CompressionLevel::BestCompression, 0);

	this->name->Release();
}

void Map::TileMapZipWriter::BeginLevel(UOSInt level)
{
	UTF8Char sbuff[64];
	UTF8Char *sptr;
	this->currLev = level;
	sptr = Text::StrUOSInt(sbuff, level);
	*sptr++ = '/';
	*sptr = 0;
	Data::Timestamp t = Data::Timestamp::UtcNow();
	this->zip.AddDir(CSTRP(sbuff, sptr), t, t, t, 0);
	this->xList.Clear();
}

void Map::TileMapZipWriter::AddX(Int32 x)
{
	UTF8Char sbuff[64];
	UTF8Char *sptr;
	OSInt k = this->xList.SortedIndexOf(x);
	if (k < 0)
	{
		this->xList.Insert((UOSInt)~k, x);
		sptr = Text::StrUOSInt(sbuff, this->currLev);
		*sptr++ = '/';
		sptr = Text::StrInt32(sptr, x);
		*sptr++ = '/';
		*sptr = 0;
		Data::Timestamp t = Data::Timestamp::UtcNow();
		this->zip.AddDir(CSTRP(sbuff, sptr), t, t, t, 0);
	}
}

void Map::TileMapZipWriter::AddImage(UOSInt level, Int32 x, Int32 y, Data::ByteArrayR imgData, Map::TileMap::ImageType imgType)
{
	UTF8Char sbuff[128];
	UTF8Char *sptr;
	sptr = Text::StrUOSInt(sbuff, level);
	*sptr++ = '/';
	sptr = Text::StrInt32(sptr, x);
	*sptr++ = '/';
	sptr = Text::StrInt32(sptr, y);
	switch (imgType)
	{
	default:
	case Map::TileMap::IT_PNG:
		sptr = Text::StrConcatC(sptr, UTF8STRC(".png"));
		break;
	case Map::TileMap::IT_WEBP:
		sptr = Text::StrConcatC(sptr, UTF8STRC(".webp"));
		break;
	case Map::TileMap::IT_JPG:
		sptr = Text::StrConcatC(sptr, UTF8STRC(".jpg"));
		break;
	}
	Data::Timestamp t = Data::Timestamp::UtcNow();
	this->zip.AddFile(CSTRP(sbuff, sptr), imgData.Ptr(), imgData.GetSize(), t, t, t, Data::Compress::Inflate::CompressionLevel::BestCompression, 0);
}
